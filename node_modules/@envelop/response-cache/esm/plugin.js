import { isAsyncIterable } from '@envelop/core';
import { visitResult } from '@graphql-tools/utils';
import { visit, TypeInfo, visitWithTypeInfo, getOperationAST, Kind } from 'graphql';
import jsonStableStringify from 'fast-json-stable-stringify';
import { createInMemoryCache } from './in-memory-cache.js';
import { hashSHA256 } from './hash-sha256.js';
import { defaultGetDocumentString, useCacheDocumentString } from './cache-document-str.js';
/**
 * Default function used for building the response cache key.
 * It is exported here for advanced use-cases. E.g. if you want to short circuit and serve responses from the cache on a global level in order to completely by-pass the GraphQL flow.
 */
export const defaultBuildResponseCacheKey = params => hashSHA256([
    params.documentString,
    params.operationName ?? '',
    jsonStableStringify(params.variableValues ?? {}),
    params.sessionId ?? '',
].join('|'));
/**
 * Default function used to check if the result should be cached.
 *
 * It is exported here for advanced use-cases. E.g. if you want to choose if
 * results with certain error types should be cached.
 *
 * By default, results with errors (unexpected, EnvelopError, or GraphQLError) are not cached.
 */
export const defaultShouldCacheResult = (params) => {
    if (params.result.errors) {
        // eslint-disable-next-line no-console
        console.warn('[useResponseCache] Failed to cache due to errors');
        return false;
    }
    return true;
};
export function useResponseCache({ cache = createInMemoryCache(), ttl: globalTtl = Infinity, session, enabled, ignoredTypes = [], ttlPerType = {}, ttlPerSchemaCoordinate = {}, idFields = ['id'], invalidateViaMutation = true, buildResponseCacheKey = defaultBuildResponseCacheKey, getDocumentString = defaultGetDocumentString, shouldCacheResult = defaultShouldCacheResult, 
// eslint-disable-next-line dot-notation
includeExtensionMetadata = typeof process !== 'undefined' ? process.env['NODE_ENV'] === 'development' : false, }) {
    const ignoredTypesMap = new Set(ignoredTypes);
    // never cache Introspections
    ttlPerSchemaCoordinate = { 'Query.__schema': 0, ...ttlPerSchemaCoordinate };
    return {
        onPluginInit({ addPlugin }) {
            if (getDocumentString === defaultGetDocumentString) {
                addPlugin(useCacheDocumentString());
            }
        },
        async onExecute(onExecuteParams) {
            let documentChanged = false;
            const newDocument = visit(onExecuteParams.args.document, {
                SelectionSet(node) {
                    if (!node.selections.some(selection => selection.kind === Kind.FIELD && selection.name.value === '__typename')) {
                        documentChanged = true;
                        return {
                            ...node,
                            selections: [
                                {
                                    kind: Kind.FIELD,
                                    name: {
                                        kind: Kind.NAME,
                                        value: '__typename',
                                    },
                                },
                                ...node.selections,
                            ],
                        };
                    }
                    return node;
                },
            });
            if (documentChanged) {
                onExecuteParams.setExecuteFn(function typeNameAddedExecute() {
                    return onExecuteParams.executeFn({
                        ...onExecuteParams.args,
                        document: newDocument,
                    });
                });
            }
            const identifier = new Map();
            const types = new Set();
            let currentTtl;
            let skip = false;
            const processResult = (result) => visitResult(result, {
                document: onExecuteParams.args.document,
                variables: onExecuteParams.args.variableValues,
                operationName: onExecuteParams.args.operationName ?? undefined,
                rootValue: onExecuteParams.args.rootValue,
                context: onExecuteParams.args.contextValue,
            }, onExecuteParams.args.schema, new Proxy({}, {
                get(_, typename) {
                    let typenameCalled = 0;
                    return new Proxy((val) => val, {
                        // Needed for leaf values such as scalars, enums etc
                        // They don't have fields so visitResult expects functions for those
                        apply(_, __, [val]) {
                            return val;
                        },
                        get(_, fieldName) {
                            if (documentChanged) {
                                if (fieldName === '__typename') {
                                    typenameCalled++;
                                }
                                if (fieldName === '__leave' &&
                                    /**
                                     * The visitResult function is called for each field in the selection set.
                                     * But visitResult function looks for __typename field visitor even if it is not there in the document
                                     * So it calls __typename field visitor twice if it is also in the selection set.
                                     * That's why we need to count the number of times it is called.
                                     *
                                     * Default call of __typename https://github.com/ardatan/graphql-tools/blob/master/packages/utils/src/visitResult.ts#L277
                                     * Call for the field node https://github.com/ardatan/graphql-tools/blob/master/packages/utils/src/visitResult.ts#L272
                                     */ typenameCalled < 2) {
                                    return (root) => {
                                        delete root.__typename;
                                        return root;
                                    };
                                }
                            }
                            if (ignoredTypesMap.has(typename)) {
                                skip = true;
                            }
                            if (skip === true) {
                                return;
                            }
                            types.add(typename);
                            if (typename in ttlPerType) {
                                currentTtl = calculateTtl(ttlPerType[typename], currentTtl);
                            }
                            if (idFields.includes(fieldName)) {
                                return (id) => {
                                    identifier.set(`${typename}:${id}`, { typename, id });
                                    return id;
                                };
                            }
                            return undefined;
                        },
                    });
                },
            }));
            const operationAST = getOperationAST(onExecuteParams.args.document, onExecuteParams.args.operationName);
            if (invalidateViaMutation !== false && operationAST?.operation === 'mutation') {
                return {
                    onExecuteDone({ result, setResult }) {
                        if (isAsyncIterable(result)) {
                            // eslint-disable-next-line no-console
                            console.warn('[useResponseCache] AsyncIterable returned from execute is currently unsupported.');
                            return;
                        }
                        const processedResult = processResult(result);
                        cache.invalidate(identifier.values());
                        if (includeExtensionMetadata) {
                            setResult({
                                ...processedResult,
                                extensions: {
                                    ...processedResult.extensions,
                                    responseCache: {
                                        ...processedResult.extensions?.responseCache,
                                        invalidatedEntities: Array.from(identifier.values()),
                                    },
                                },
                            });
                        }
                    },
                };
            }
            const cacheKey = await buildResponseCacheKey({
                documentString: getDocumentString(onExecuteParams.args),
                variableValues: onExecuteParams.args.variableValues,
                operationName: onExecuteParams.args.operationName,
                sessionId: session(onExecuteParams.args.contextValue),
            });
            if ((enabled?.(onExecuteParams.args.contextValue) ?? true) === true) {
                const cachedResponse = (await cache.get(cacheKey));
                if (cachedResponse != null) {
                    if (includeExtensionMetadata) {
                        onExecuteParams.setResultAndStopExecution({
                            ...cachedResponse,
                            extensions: {
                                ...cachedResponse.extensions,
                                responseCache: {
                                    ...cachedResponse.extensions?.responseCache,
                                    hit: true,
                                },
                            },
                        });
                    }
                    else {
                        onExecuteParams.setResultAndStopExecution(cachedResponse);
                    }
                    return;
                }
            }
            if (ttlPerSchemaCoordinate) {
                const typeInfo = new TypeInfo(onExecuteParams.args.schema);
                visit(onExecuteParams.args.document, visitWithTypeInfo(typeInfo, {
                    Field(fieldNode) {
                        const parentType = typeInfo.getParentType();
                        if (parentType) {
                            const schemaCoordinate = `${parentType.name}.${fieldNode.name.value}`;
                            const maybeTtl = ttlPerSchemaCoordinate[schemaCoordinate];
                            if (maybeTtl !== undefined) {
                                currentTtl = calculateTtl(maybeTtl, currentTtl);
                            }
                        }
                    },
                }));
            }
            return {
                onExecuteDone({ result, setResult }) {
                    if (isAsyncIterable(result)) {
                        // eslint-disable-next-line no-console
                        console.warn('[useResponseCache] AsyncIterable returned from execute is currently unsupported.');
                        return;
                    }
                    const processedResult = processResult(result);
                    if (skip) {
                        return;
                    }
                    if (!shouldCacheResult({ cacheKey, result: processedResult })) {
                        return;
                    }
                    // we only use the global ttl if no currentTtl has been determined.
                    const finalTtl = currentTtl ?? globalTtl;
                    if (finalTtl === 0) {
                        if (includeExtensionMetadata) {
                            setResult({
                                ...processedResult,
                                extensions: {
                                    ...processedResult.extensions,
                                    responseCache: {
                                        ...processedResult.extensions?.responseCache,
                                        hit: false,
                                        didCache: false,
                                    },
                                },
                            });
                        }
                        return;
                    }
                    cache.set(cacheKey, processedResult, identifier.values(), finalTtl);
                    if (includeExtensionMetadata) {
                        setResult({
                            ...processedResult,
                            extensions: {
                                ...processedResult.extensions,
                                responseCache: {
                                    ...processedResult.extensions?.responseCache,
                                    hit: false,
                                    didCache: true,
                                    ttl: finalTtl,
                                },
                            },
                        });
                    }
                },
            };
        },
    };
}
function calculateTtl(typeTtl, currentTtl) {
    if (typeof currentTtl === 'number') {
        return Math.min(currentTtl, typeTtl);
    }
    return typeTtl;
}
